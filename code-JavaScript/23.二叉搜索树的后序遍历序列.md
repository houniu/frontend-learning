# 23.二叉搜索树的后序遍历序列

[《剑指 Offer》刷题 GitHub 链接](https://github.com/zhning12/Coding-Interviews)

[题目链接](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同。

## 解题思路

- 二叉搜索树的特点：某一个节点左子树的所有节点的值都比该节点小，右子树的所有节点的值都比该节点大
- 依次与数组最后一个值比较，一直小于最后一个数的是左子树的，计数，剩下的是右子树的，依次判断剩下的是否全部大于最后一个数，若否，则为 false。
- 使用递归，依次判断每一个子数组是否满足  上一个条件

- 小技巧：将返回`true`的条件由`s==e`改为`s>=e`，则无需判断是否有`lessE == s || lessE == e`，直接`return judge(arr,s,lessE-1) && judge(arr,lessE,e-1)`即可。（否则会出现`s<e`的情况）

## Code

```javascript
function VerifySquenceOfBST(sequence) {
  // write code here
  function judge(arr, s, e) {
    if (s >= e) {
      return true;
    }
    var lessE = s;
    while (arr[lessE] < arr[e] && lessE < e) {
      lessE++;
    }
    var largeE = lessE;
    while (arr[largeE] > arr[e] && largeE < e) {
      largeE++;
    }
    if (largeE < e) {
      return false;
    }
    return judge(arr, s, lessE - 1) && judge(arr, lessE, e - 1);
  }

  if (sequence.length == 0) {
    return false;
  }
  return judge(sequence, 0, sequence.length - 1);
}
```
