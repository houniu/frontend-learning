# 4.重建二叉树

[《剑指 Offer》刷题 GitHub 链接](https://github.com/zhning12/Coding-Interviews)

[题目链接](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

## 解题思路

1. 这里使用的是递归
2. 前序遍历(pre)的第一个`pre[0]`必是当前的 root 节点
3. 中序遍历(vin)到`pre[0]`的这一段必是当前的左子树，`pre[0]`到最后的必是当前的右子树

## Code

```javascript
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function reConstructBinaryTree(pre, vin) {
  // write code here
  if (pre.length == 0) {
    return;
  }
  var treeNode = {
    val: pre[0],
  };
  for (var i = 0; i < pre.length; i++) {
    if (vin[i] == pre[0]) {
      treeNode.left = reConstructBinaryTree(
        pre.slice(1, i + 1),
        vin.slice(0, i)
      );
      treeNode.right = reConstructBinaryTree(
        pre.slice(i + 1),
        vin.slice(i + 1)
      );
    }
  }
  return treeNode;
}
```
